#
# This file contains functions used by btrfs-borg
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License v2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# Copyright (C) 2016-2017  Nicholas D Steeves <nsteeves@gmail.com>

# TODO: Go through this an recapitalise variables that now need global
# scope.


# function: Checks that only admins can access $ADMIN_DIR and offers to fix
#           unsafe permissions.
#
# parameter: NA
check_permissions() {
    admin_dir_mod=($(stat -L -c "%G:%U %a" $ADMIN_DIR))
    admin_own=${admin_dir_mod[0]}
    other_perm=${admin_dir_mod[1]:2}
    if [ $admin_own != "root:$ADMIN_GROUP" -o $admin_own != "root:root" ] \
           && [ $other_perm -ne 0 ]; then
        echo -n "Unsafe permissions for $ADMIN_DIR.  Fix? (y/n)  "
        while true; do
            read choice
            case "$choice" in
                yes | y | Yes | YES )
                    chown root:root $ADMIN_DIR
                    chmod 750 $ADMIN_DIR
                    cat <<EOF
Owner/permissions changed to root:root/750.  To allow sudoers to access
access $ADMIN_DIR, "chgrp sudo $ADMIN_DIR" and set \$ADMIN_GROUP in
btrfs-borg config.
EOF
                    break
                    ;;
                no | n | No | NO )
                    cat <<EOF
Btrfs-borg will terminate now, due to unsafe permissions in $ADMIN_DIR.
EOF
                    exit 13
                    # permission denied
                    ;;
                * )
                    echo -n "Please answer yes or no.  "
                    ;;
            esac
        done
    fi
}

# function: trim leading and trailing whitespace from strings
# parameter: one string
# returns: trimmed string
#
# Used in get_uniq_devs(), and for trimming each field config.csv
trim_whitespace() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    local string
    string="$*"
    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
    echo -n "$string"
}

# function: returns a space-separated list of btrfs devices,
#           with one device per volume (eg: /dev/sda1)
# parameter: NA
# requires: trim_whitespace()
#
# Adapted from btrfsmaintenance-functions evaluate_auto_mountpoint()
get_uniq_devs() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    local devices
    devices=$(findmnt --types btrfs --noheadings --output "SOURCE" --nofsroot \
                      --noheading | sort | uniq | tr '\n' ' ')
    trim_whitespace $devices
    # /\ I think bash does this automatically!
    # eg: for a dir with a bunch of 2017-12-24 type dates
    # foo=`ls | grep -P -o '[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]' | sort | uniq`
    # normally the command outputs each new file on a new line
    # but for some reason when assigning to a variable the leading whitespace
    # gets automatically trimmed, and the newlines are changed to spaces
    # echo -n $foo  > /tmp/garb && echo -n $foo  >> /tmp/garb
    # /\ proves this
}

# function: gets volume LABEL if possible and returns it, otherwise
#           returns basename of parameter (eg: sda1)
# parameter: takes one block device or partition (eg: /dev/sda1)
get_label() {
    if [ -z ${1+x} ]; then
        return 15
        # block device required
    fi
    local label
    label=$(lsblk -J -oLABEL $1 | grep label | awk -F\" '{print $4}')
    # alternatively btrfs property get -t filesystem $1 label
    # will print 'label=This_is_this_label'
    if [ ! -z "$label" ]; then
        echo -n "$label"
    else
        echo -n "$(basename $1)"
    fi
}

# parameter: takes a path to a file or directory
# returns: boolean
is_btrfs() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    if [ "$(stat -f --format=%T $1)" == 'btrfs' ]; then
        echo "$1 is part of a btrfs volume"
    else
        echo "$1 is not part of a btrfs volume"
        false
    fi
}

# returns: boolean
is_subvol() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    if [ "$(stat -f --format=%T $1)" == 'btrfs' ] \
           && [ "$(stat --format=%i $1)" -eq 256 ]; then
        echo "$1 is a btrfs subvolume"
    else
        echo "$1 is not a btrfs subvolume"
        false
    fi
}

# parameter: TODO
# returns: TODO
get_parent_uuid() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    btrfs subvolume list -o -u -q -r $1/.. # ????
    false
    # error for now TODO: Needs to be written
    #     btrfs subvolume list -q <- enable this later
}

# TODO: write this function!
# parameter: string, takes one volume root (subvolid=5 | subvol=/)
# returns: TO BE WRITTEN
list_ro_subvols() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    btrfs subvolume list -o -u -q -r $1/.. # ????
}

# parameter: string, takes a path to a subvolume
# returns: boolean
is_subvol_ro() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    if [ "$(btrfs property get -t subvol $1)" = "ro=true" ]; then
        true
    else
        false
    fi
}

# function: returns true if an LX container is found
# parameter: filesystem path
# TODO: write it
#       merge it into get_lxc_rootfs?
is_lxc() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    echo "check for existence of $1/config?"
    echo "avoid using grep!"  # <-  really?  Why?
    echo "grep $1/config for REGEX lxc.rootfs.backend.*btrfs"
}

# function: This function ensures that the top-down full-tree view of
#           a volume is visible to btrfs-borg.  It creates the
#           required directory structure, mounts the volume[s], and
#           creates $SNAPS_DIR
#
# parameter: accepts either single labels/devices or a list
# requires: get_label()
create_mount_points() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    for i in "$@"; do
        local label_or_dev
        label_or_dev=$(get_label $i)
        echo "Creating temporary mount point for $label_or_dev"
        exit 1
        # TODO: needs check to see if $ADMIN_DIR/$label_or_dev is already
        #       mounted
        mount -o noatime $i $ADMIN_DIR/$label_or_dev
        mkdir -p $ADMIN_DIR/$label_or_dev/$SNAPS_DIR
    done
}

# function: tests arg to see if it is a bizarrely named local path or
#           or if it is ssh connected
# parameter: string, /path/to/borg/repo, or
#            user@host:/path/to/borg/repo
# returns: exit code
repo_exists() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    # let's suppose $1=bizarre@dir_name:has:colons/oh/no
    if [ -e "$1" ]; then
        echo "Please consider naming $1 without @s and :s"
        echo "It looks like bizarre@dir_name:has:colons/oh/no"
        # Check for existence of borg repo
        if [ ! -f "$1/config" ]; then
            cat <<EOF
$1/config not found!
Is your backup target disk plugged in and mounted?
Did you initialise the borg repository?
EOF
            return 2
            # no such file or directory
        fi
    else
        local remuser; local remhost; local remrepo
        remuser="$(echo -n $1 | cut -d@ -f1)"
        remhost="$(echo -n $1 | cut -d@ -f2 | cut -d: -f1)"
        remrepo="$(echo -n $1 | cut -d: -f2)"
        # Check for existence of borg repo
        if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
            ssh $remuser@$remhost "test -e $remrepo/config"
            if [ $? -ne 0 ]; then
                cat <<EOF
$1/config not found!
Is your backup target disk plugged in and mounted?
Did you initialise the borg repository?
EOF
                return 14
                # bad address
            fi
            echo "Configuration found for $repo"
        fi
    fi
}

# function: Other sanity checks
# parameter: To be written
# TODO: needs to iterate for new $backup_srcs
#       Other sanity checks.
#       CLEANUP -> move these to immediately before snapshot is taken
# TODO: needs magic!  Possibly needs rewrite...  eg: right now it
#       needs both $ADMIN_DIR/$label_or_dev/$SNAPS_DIR AND the backup
#       src-object...but I haven't written the automatically find
#       src-object (eg: subvolume) yet.  The loop should probably be
#       external to the function.
pre_snapshot() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    cd "$ROOT/$SNAPS_DIR"
    for i in $subs; do
        if [ -d "$i" ]; then
            local orig_date
            orig_date=$(stat -c %Y "$i")
            # this \/ isn't very nice...
            # make snapshots as btrfs-borg-$i or $i.borg-snap instead
            echo "Moving existing snapshot of $i out of the way to
$i@$AGE"
            echo "TODO make snapshots as btrfs-borg_$i or $i.borg-snap instead"
            mv "$i" "$i"@"$orig_date"
        fi
        sync
        btrfs subvolume sync "$ROOT"
        sync
    done
}

# function:
# parameter: LX container path
# TODO: make this function actually work
#       merge it into get_lxc_rootfs?
#     ! Remember, this needs to be done from /btrfs-admin/$VOLUME/FS-TREE !
#       Ahh...Maybe it should take a /real/path/to/container, and
#       return /btrfs-admin/$volume/FS-TREE/$LXC-container
#       And/Or take a $container-name without a path and find it using
#       /sbin/btrfs, and return /a/real/path/rootfs
get_lxc_rootfs() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    # from main(), use this function to test and get an LXC backup object
    #at this point $1=$ROOT from $f1 in main() eg: /btrfs-admin/SanDisk
    #at this point $2="/var/lib/lxc/my-container" from $f2 in main()
    is_btrfs $1/$2/rootfs
    ### Test for failure, echo MISCONFIGURED BTRFS-BORG and cleanup
    if [ $? -eq 0 ]; then
        #return the full path of subvol to snapshot
        echo -n "$1/$2/rootfs"
    else
        false
    fi
    cat <<EOF
OR DO IT THIS WAY:

sudo btrfs subvolume list /btrfs-admin/Blue
PRINTS:

ID 257 gen 927355 top level 5 path @rootfs
ID 282 gen 927355 top level 5 path @home
ID 335 gen 695496 top level 257 path @rootfs/srv
ID 511 gen 927351 top level 257 path @rootfs/var/lib/lxc/my-container/rootfs

Then, from inside /btrfs-admin/Blue, do:

btrfs subvolume snaphot -r @rootfs/var/lib/lxc/my-container/rootfs \
    snapshots/my-container

This seems like a slightly better style than:
  from inside /btrfs-admin/Blue/snapshots, do:

btrfs subvolume snapshot -r ../@rootfs/var/lib/lxc/my-container/rootfs \
    snapshots/my-container

EOF
}

# function:
# parameter:
# TODO: Make this function work
#   !  #1 Decide whether or not to make it configurable whether
#           $container is treated as a named src object (eg: #2), of
#           if it should be grafted into its FS_TREE location.
#        - In the case of the later, containers backups will probably be
#           part of the OS's medium-or-long-term rootfs backup retention policy
#        - Additionally, in the later case they are NOT part of the archive name
#        - in the former named-object case they ARE part of the archive name.
#       #2 recreate the layout of /p/to/container (without rootfs) in
#       /btrfs-admin/$volume/snapshots/$container_name
#       Hey! Put a file like /path/to/container/quiesce to trigger an lxc-stop
#       When that's done snapshot to /b-a/$vol/snap/$container_name/rootfs
#           and immediately run lxc-start
#       This special-name file is *optional*
#           * Email the LXC mailing list to find out if there's already a
#             place where this desired behaviour can be configured and use
#             that instead of my special-name file.
#       #2 Backup proceeds as normal with backup object of:
#            /btrfs-admin/$volume/snapshots/@container_name
#
# ALSO: ...what about snapshots that are already in /var/lib/lxc/C/snaps?
#       by default these subvolumes will be excluded from the backup!
#       #1: btrfs snapshot -r /var/lib/lxc/get-transmissions/snap/snap$i/rootfs
#           in a loop to /btrfs-admin/$vol/snapshots/@rootfs/FS_TREE/snap$i
#         - this works, as long as the correct parent volume is detected.
lxc_snapshot() {
    if [ -z ${1+x} ]; then
        return 22
        # invalid argument
    fi
    if [ -n "$containers" ]; then
        unset lxcsnaps
        for i in $containers; do
            lxc-stop -n "$i"
            lxc-snapshot -n "$i"
            sync
            btrfs subvolume sync "$lxcdir"
            sync
            lxc-start -n "$i"
            if [ -z "$lxcsnaps" ]; then
                lxcsnaps="$(btrfs subvolume list $lxcdir | grep $i | tail -n1 | awk '{print $NF}')"
            else
                lxcsnaps="$lxcsnaps $(btrfs subvolume list $lxcdir | grep $i | tail -n1 | awk '{print $NF}')"
            fi
        done
        containers="$(echo $containers | tr ' ' '_')"
        lcontains="_"
        lcontains="$lcontains$containers"
    fi
}

# function:
# parameter:
# TODO: this one will require careful thought and reworking
prepare () {
    echo "Preparing..."
    sync
    btrfs subvolume sync "$ROOT"
    sync
    for i in $subs; do
        btrfs subvolume snapshot -r "$ROOT/$i" "$ROOT/$SNAPS_DIR/$i"
        sync
        btrfs subvolume sync "$ROOT/$SNAPS_DIR/$i"
        sync
    done
    lsubs="$(echo $subs | tr ' ' '_')"
    if [ -n "$others" ]; then
        dirs=""
        for i in $others; do
            dirs="$dirs $(basename $i)"
        done
        dirs="$(echo $dirs | tr ' ' '_')"
        loths="_"
        loths="$loths$dirs"
    fi
}

# function:
# parameter:
# TODO: "main()" runs somewhere in the loop that iterates through each
#       $backup_unit, one per line, from the CSV.
# IMPORTANT: TODO of lxc_snapshot() profoundly affects this function
do_backup() {
    echo "Doing backup (TODO: Needs to take vars from \$backup_unit"
    cd $ROOT/$SNAPS_DIR
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        stats=$HOME/time_stats_$DATE
    else
        stats=$repo/time_stats_$DATE
    fi
    borg create $verbos -p --stats $extraargs -C $comp \
         --exclude-caches \
         $repo::$lsubs$lcontains$loths-on-epoch+$DATE\.$comp \
         $subs $lxcsnaps $others
}

# function: cleans up a bunch of stuff
# parameter: /btrfs-admin/???/???  Need to think this through
# TODO: Make it actually work
#       Must always clean up ALL snapshots by default
cleanup() {
    echo "Cleaning up Snapshots"
    (time (
         cd $ROOT/$SNAPS_DIR
         btrfs subvolume delete -c $subs
         echo "Syncing...please be patient, this could be slow"
         sync
         btrfs subvolume sync $ROOT
         sync)
     2>&3) 3>&2 2> $stats
    echo -n "Cleanup took "
    cat $stats
    echo
}

# function: ah, the tricky pruning function...
# parameter: single lines from $back_unit CSV?  $prefix and $src objects?
#            LOCAL VARS from backup_unit
# TODO: Make this actually work
#       BACKUP_UNITS='/btrfs-admin/Red, @stuff @more
#       /btrfs-admin/Blue, @ @home /var/lib/lxc/my-container '
#     - Means my naming scheme needs to be:
#         get basename of $ROOT
#         if basename is /btrfs-admin, then do nothing
#         else, BS=Blue
#           $HOSTNAME-$BS-@stuff_@more is the creation and pruning prefix
#           True-Blue-@_@home_my-container_$DATE
prune() {
    unset prune
    if [ -n "$hourly" ]; then prune="-H $hourly"; fi
    if [ -n "$daily" ]; then prune="$prune -d $daily"; fi
    if [ -n "$weekly" ]; then prune="$prune -w $weekly"; fi
    if [ -n "$monthly" ]; then prune="$prune -m $monthly"; fi
    if [ -n "$yearly" ]; then prune="$prune -y $yearly"; fi
    if [ -n "$prune" ]; then
        echo "Initiating pruning.  Please do not be alarmed if this takes forever"
        (time borg prune $verbos --stats $prune $repo 2>&3) \
            3>&2 2> $stats
        echo -n "Pruning took "
        cat $stats
        echo
        rm $stats
    fi
    # TODO: do something about \/ THIS \/
    base=`basename $ROOT`
}

# function:
# parameter: Hmmm...does it need any?
# TODO:  Bundle stuff: Needs a better name?
#        Needs to do something smart with respect to $backup_unit
bundle_stuff() {
    # Bundle stuff that will make restoring from backup easier
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        ssh $remuser@$remhost "install -d -m 700  $remrepo/btrfs-borg"
        if [ -z ${archiveids+x} ]; then
            borg list $repo > $HOME/borg-list.$DATE
            chmod 400 $HOME/borg-list.$DATE
            # Add immutable ACL to $btrfs_borg-list.$DATE?
            scp $HOME/borg-list.$DATE \
                $remuser@$remhost:$remrepo/btrfs-borg/borg-list.$DATE && \
                rm $HOME/borg-list.$DATE
        fi
        ssh $remuser@$remhost "test -e $remrepo/btrfs-borg/$btrfs_borg"
        if [ $? -eq 0 ]; then
            ssh $remuser@$remhost "mv $remrepo/btrfs-borg/$btrfs_borg $remrepo/btrfs-borg/$btrfs_borg.old"
        fi
        install -m 500 "$0" $HOME/"$btrfs_borg.${DATE}" && \
            scp $HOME/$btrfs_borg.$DATE \
                $remuser@$remhost:$remrepo/btrfs-borg/$btrfs_borg && \
            rm $HOME/"$btrfs_borg.${DATE}"
        # \/ TODO \/
        #install -d -m 400 $BTRFS-BORG.CSV $repo/btrfs-borg/$BTRFS-BORG.CSV
        # TODO: make this iterate for multiple ROOTS
        btrfs subvolume list $ROOT | ssh $remuser@$remhost "cat > $remrepo/btrfs-borg/subvolumes_of_$base"
    else
        # Bundle stuff that will make restoring from backup easier
        mkdir -p $repo/btrfs-borg && chown 700 $repo/btrfs-borg
        if [ -f $repo/btrfs-borg/$btrfs_borg ]; then
            mv $repo/btrfs-borg/$btrfs_borg $repo/btrfs-borg/$btrfs_borg.old
        fi
        install -d -m 500 "$0" $repo/btrfs-borg/$btrfs_borg
        if [ -z ${archiveids+x} ]; then
            borg list $repo > $repo/btrfs-borg/borg-list.$DATE
            chmod 400 $repo/btrfs-borg/borg-list.$DATE
            # Add immutable ACL to $btrfs_borg-list.$DATE?
        fi
        # \/ TODO \/
        #install -d -m 400 $BTRFS-BORG.CSV $repo/btrfs-borg/$BTRFS-BORG.CSV
        # TODO: make this iterate for multiple ROOTS
        btrfs subvolume list $ROOT > $repo/btrfs-borg/subvolumes_of_$base
    fi
}

# function: see below
# parameter: ???
verify() {
    echo "do verification"
    echo success || fail from $? according to VERBOS setting
    # get verbos setting from `which btrfs-borg?`
    # get the list of archives to verify from somewhere
    # it would also be good to have a more verbose way to
    # verify the whole repo

    # That said, I'm thinking about using the epoch+seconds
    # thing to allow verification of all archives since 34198723649
    # eg: verify_since=`date -d "-3 month" +%s`
    # parse the date stamp, and if >= $verify_since then borg extract
    # --dry-run it

    # Alternatively, get the date stamp of the most recent archive, and verify
    # all archives taken from that (value minus 24h) range.

    # When borg supports it, switch to using --verify-data
}
