#
# This file contains functions used by btrfs-borg
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License v2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# Copyright (C) 2016-2017  Nicholas D Steeves <nsteeves@gmail.com>

# TODO: Go through this an recapitalise variables that now need global
# scope.

# function: trim leading and trailing whitespace from strings
# parameter: string, taken from a field of a CSV
# TODO: test to see if this is truly necessary, and if not, drop it
trim() {
    string="$*" ; local string
    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
    printf "$string"
}

# function: returns a space-separated list of btrfs devices,
#           with one device per volume (eg: /dev/sda1)
# parameter: NA
get_uniq_devs() {
    findmnt --types btrfs --noheadings --output "SOURCE" --nofsroot \
            --noheading | sort | uniq | tr '\n' ' '
}

# function: gets volume LABEL if possible and returns it, otherwise
#           returns basename of parameter
# parameter: takes one block device or partition (eg: /dev/sda1)
try_get_label() {
    device=$(blkid | grep $1) ; local device
    label=${device##*\ LABEL=}
    label=${label%%\ *} ; local label
    if [ ! -z "$label" ]; then
        printf "$label"
    else
        printf "${basename $device}"
    fi
}

# function: Other sanity checks
# parameter: To be written
# TODO: needs to iterate for new $backup_srcs
#       Other sanity checks.
#       CLEANUP -> move these to immediately before snapshot is taken
pre_snapshot() {
    if [ -d "$ROOT/$SNAPS_DIR" ]; then
        cd "$ROOT/$SNAPS_DIR"
        for i in $subs; do
            if [ -d "$i" ]; then
                AGE=$(stat -c %Y "$i")
                # this \/ isn't very nice...
                # make snapshots as btrfs-borg-$i or $i.borg-snap instead
                echo "Moving existing snapshot of $i out of the way to
$i@$AGE"
                echo "TODO make snapshots as btrfs-borg_$i or $i.borg-snap instead"
                mv "$i" "$i"@"$AGE"
            fi
            sync
            btrfs sub sync "$ROOT"
            sync
        done
    else
        cat <<EOF
REPLACE THE FOLLOWING SECTION WITH MKDIR -P...ALWAYS WORKS, AND
ALWAYS SILENT ;-)
EOF
        echo "$ROOT/$SNAPS_DIR not found! $COMMAND cannot continue."
        echo "create $ROOT/$SNAPS_DIR?"
        if [ -z ${NOTFOUND+x} ]; then
            echo -n "Proceed? "
            while true; do
                read choice
                case "$choice" in
                    yes | y | Yes | YES )
                        echo "Creating $SNAPS_DIR"
                        install -d -m 700
                        break
                        ;;
                    no | n | No | NO )
                        echo "Exiting safely."
                        exit 1
                        ;;
                    * )
                        printf "Please answer yes or no\n\n"
                        ;;
                esac
            done
        fi
        exit 1
    fi

    # PREP-STUFF.  TARGET FOR CLEANUP!
    # TODO: Make it a function
    # LOCAL VARS
    remuser="$(echo $repo | cut -d@ -f1)"
    remhost="$(echo $repo | cut -d@ -f2 | cut -d: -f1)"
    remrepo="$(echo $repo | cut -d: -f2)"

    # TODO: non-iterable sanity checks TARGET FOR CLEANUP!
    # Check for existence of intended borg REPO
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        ssh $remuser@$remhost "test -e $remrepo/config"
    elif [ ! -f "$repo/config" ]; then
        false
    fi
    if [ $? -ne 0 ]; then
        cat <<EOF
$repo/config not found!
Is your backup target disk plugged in and mounted?
Did you initialise the borg repository?
EOF
        exit 1
    fi
    echo "Configuration found for $repo"
}
# end pre_snapshot()

is_btrfs() {
    if [ "$(stat -f --format=%T $1)" == 'btrfs' ]; then
        echo "$1 is a btrfs volume"
    else
        echo "$1 is not a btrfs volume"
    fi
}

is_subvolume() {
    if [ "$(stat -f --format=%T $1)" == 'btrfs' ] && \
           [ "$(stat --format=%i $1)" -eq 256 ]; then
        echo "$1 is a btrfs subvolume"
    else
        echo "$1 is not a btrfs subvolume"
        false
    fi
}

# function: returns true if an LX container is found
# parameter: filesystem path
# TODO: write it
#       merge it into get_lxc_rootfs?
is_lxc() {
    echo "check for existence of $1/config?"
    echo "avoid using grep!"
    echo "grep $1/config for REGEX lxc.rootfs.backend.*btrfs"
}

# function:
# parameter: LX container path
# TODO: make this function actually work
#       merge it into get_lxc_rootfs?
#     ! Remember, this needs to be done from /btrfs-admin/$VOLUME/FS-TREE !
#       Ahh...Maybe it should take a /real/path/to/container, and
#       return /btrfs-admin/$volume/FS-TREE/$LXC-container
#       And/Or take a $container-name without a path and find it using
#       /sbin/btrfs, and return /a/real/path/rootfs
get_lxc_rootfs() {
    # from main(), use this function to test and get an LXC backup object
    #at this point $1=$ROOT from $f1 in main() eg: /btrfs-admin/SanDisk
    #at this point $2="/var/lib/lxc/my-container" from $f2 in main()
    is_btrfs $1/$2/rootfs
    ### Test for failure, echo MISCONFIGURED BTRFS-BORG and cleanup
    if [ $? -eq 0 ]; then
        #return the full path of subvol to snapshot
        echo -n "$1/$2/rootfs"
    else
        false
    fi
    cat <<EOF
OR DO IT THIS WAY:

sudo btrfs sub list /btrfs-admin/Blue
PRINTS:

ID 257 gen 927355 top level 5 path @rootfs
ID 282 gen 927355 top level 5 path @home
ID 335 gen 695496 top level 257 path @rootfs/srv
ID 511 gen 927351 top level 257 path @rootfs/var/lib/lxc/my-container/rootfs

Then, from inside /btrfs-admin/Blue, do:

btrfs sub snap -r @rootfs/var/lib/lxc/my-container/rootfs \
    snapshots/my-container

This seems like a slightly better style than:
  from inside /btrfs-admin/Blue/snapshots, do:

btrfs sub snap -r ../@rootfs/var/lib/lxc/my-container/rootfs \
    snapshots/my-container

EOF
}

# function:
# parameter:
# TODO: Make this function work
#   !  #1 Decide whether or not to make it configurable whether
#           $container is treated as a named src object (eg: #2), of
#           if it should be grafted into its FS_TREE location.
#        - In the case of the later, containers backups will probably be
#           part of the OS's medium-or-long-term rootfs backup retention policy
#        - Additionally, in the later case they are NOT part of the archive name
#        - in the former named-object case they ARE part of the archive name.
#       #2 recreate the layout of /p/to/container (without rootfs) in
#       /btrfs-admin/$volume/snapshots/$container_name
#       Hey! Put a file like /path/to/container/quiesce to trigger an lxc-stop
#       When that's done snapshot to /b-a/$vol/snap/$container_name/rootfs
#           and immediately run lxc-start
#       This special-name file is *optional*
#           * Email the LXC mailing list to find out if there's already a
#             place where this desired behaviour can be configured and use
#             that instead of my special-name file.
#       #2 Backup proceeds as normal with backup object of:
#            /btrfs-admin/$volume/snapshots/@container_name
#
# ALSO: ...what about snapshots that are already in /var/lib/lxc/C/snaps?
#       by default these subvolumes will be excluded from the backup!
#       #1: btrfs snapshot -r /var/lib/lxc/get-transmissions/snap/snap$i/rootfs
#           in a loop to /btrfs-admin/$vol/snapshots/@rootfs/FS_TREE/snap$i
#         - this works, as long as the correct parent volume is detected.
lxc_snapshot() {
    if [ -n "$containers" ]; then
        unset lxcsnaps
        for i in $containers; do
            lxc-stop -n "$i"
            lxc-snapshot -n "$i"
            sync
            btrfs sub sync "$lxcdir"
            sync
            lxc-start -n "$i"
            if [ -z "$lxcsnaps" ]; then
                lxcsnaps="$(btrfs sub list $lxcdir | grep $i | tail -n1 | awk '{print $NF}')"
            else
                lxcsnaps="$lxcsnaps $(btrfs sub list $lxcdir | grep $i | tail -n1 | awk '{print $NF}')"
            fi
        done
        containers="$(echo $containers | tr ' ' '_')"
        lcontains="_"
        lcontains="$lcontains$containers"
    fi
}

# function:
# parameter:
# TODO: this one will require careful thought and reworking
prepare () {
    echo "Preparing..."
    sync
    btrfs sub sync "$ROOT"
    sync
    for i in $subs; do
        btrfs sub snap -r "$ROOT/$i" "$ROOT/$SNAPS_DIR/$i"
        sync
        btrfs sub sync "$ROOT/$SNAPS_DIR/$i"
        sync
    done
    lsubs="$(echo $subs | tr ' ' '_')"
    if [ -n "$others" ]; then
        dirs=""
        for i in $others; do
            dirs="$dirs $(basename $i)"
        done
        dirs="$(echo $dirs | tr ' ' '_')"
        loths="_"
        loths="$loths$dirs"
    fi
}

# function:
# parameter:
# TODO: "main()" runs somewhere in the loop that iterates through each
#       $backup_unit, one per line, from the CSV.
# IMPORTANT: TODO of lxc_snapshot() profoundly affects this function
do_backup() {
    echo "Doing backup (TODO: Needs to take vars from \$backup_unit"
    cd $ROOT/$SNAPS_DIR
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        stats=$HOME/time_stats_$DATE
    else
        stats=$repo/time_stats_$DATE
    fi
    borg create $verbos -p --stats $extraargs -C $comp \
         --exclude-caches \
         $repo::$lsubs$lcontains$loths-on-epoch+$DATE\.$comp \
         $subs $lxcsnaps $others
}

# function: cleans up a bunch of stuff
# parameter: /btrfs-admin/???/???  Need to think this through
# TODO: Make it actually work
#       Must always clean up ALL snapshots by default
cleanup() {
    echo "Cleaning up Snapshots"
    (time (
            cd $ROOT/$SNAPS_DIR
            btrfs sub delete -c $subs
            echo "Syncing...please be patient, this could be slow"
            sync
            btrfs sub sync $ROOT
            sync)
     2>&3) 3>&2 2> $stats
    echo -n "Cleanup took "
    cat $stats
    echo
}

# function: ah, the tricky pruning function...
# parameter: single lines from $back_unit CSV?  $prefix and $src objects?
#            LOCAL VARS from backup_unit
# TODO: Make this actually work
#       BACKUP_UNITS='/btrfs-admin/Red, @stuff @more
#       /btrfs-admin/Blue, @ @home /var/lib/lxc/my-container '
#     - Means my naming scheme needs to be:
#         get basename of $ROOT
#         if basename is /btrfs-admin, then do nothing
#         else, BS=Blue
#           $HOSTNAME-$BS-@stuff_@more is the creation and pruning prefix
#           True-Blue-@_@home_my-container_$DATE
prune() {
    unset prune
    if [ -n "$hourly" ]; then prune="-H $hourly"; fi
    if [ -n "$daily" ]; then prune="$prune -d $daily"; fi
    if [ -n "$weekly" ]; then prune="$prune -w $weekly"; fi
    if [ -n "$monthly" ]; then prune="$prune -m $monthly"; fi
    if [ -n "$yearly" ]; then prune="$prune -y $yearly"; fi
    if [ -n "$prune" ]; then
        echo "Initiating pruning.  Please do not be alarmed if this takes forever"
        (time borg prune $verbos --stats $prune $repo 2>&3) \
            3>&2 2> $stats
        echo -n "Pruning took "
        cat $stats
        echo
        rm $stats
    fi
    # TODO: do something about \/ THIS \/
    base=`basename $ROOT`
}

# function:
# parameter: Hmmm...does it need any?
# TODO:  Bundle stuff: Needs a better name?
#        Needs to do something smart with respect to $backup_unit
bundle_stuff() {
    # Bundle stuff that will make restoring from backup easier
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        ssh $remuser@$remhost "install -d -m 700  $remrepo/btrfs-borg"
        if [ -z ${archiveids+x} ]; then
            borg list $repo > $HOME/borg-list.$DATE
            chmod 400 $HOME/borg-list.$DATE
            # Add immutable ACL to $btrfs_borg-list.$DATE?
            scp $HOME/borg-list.$DATE \
                $remuser@$remhost:$remrepo/btrfs-borg/borg-list.$DATE && \
                rm $HOME/borg-list.$DATE
        fi
        ssh $remuser@$remhost "test -e $remrepo/btrfs-borg/$btrfs_borg"
        if [ $? -eq 0 ]; then
            ssh $remuser@$remhost "mv $remrepo/btrfs-borg/$btrfs_borg $remrepo/btrfs-borg/$btrfs_borg.old"
        fi
        install -m 500 "$0" $HOME/"$btrfs_borg.${DATE}" && \
            scp $HOME/$btrfs_borg.$DATE \
                $remuser@$remhost:$remrepo/btrfs-borg/$btrfs_borg && \
            rm $HOME/"$btrfs_borg.${DATE}"
        # \/ TODO \/
        #install -d -m 400 $BTRFS-BORG.CSV $repo/btrfs-borg/$BTRFS-BORG.CSV
        # TODO: make this iterate for multiple ROOTS
        btrfs sub list $ROOT | ssh $remuser@$remhost "cat > $remrepo/btrfs-borg/subvolumes_of_$base"
    else
        # Bundle stuff that will make restoring from backup easier
        mkdir -p $repo/btrfs-borg && chown 700 $repo/btrfs-borg
        if [ -f $repo/btrfs-borg/$btrfs_borg ]; then
            mv $repo/btrfs-borg/$btrfs_borg $repo/btrfs-borg/$btrfs_borg.old
        fi
        install -d -m 500 "$0" $repo/btrfs-borg/$btrfs_borg
        if [ -z ${archiveids+x} ]; then
            borg list $repo > $repo/btrfs-borg/borg-list.$DATE
            chmod 400 $repo/btrfs-borg/borg-list.$DATE
            # Add immutable ACL to $btrfs_borg-list.$DATE?
        fi
        # \/ TODO \/
        #install -d -m 400 $BTRFS-BORG.CSV $repo/btrfs-borg/$BTRFS-BORG.CSV
        # TODO: make this iterate for multiple ROOTS
        btrfs sub list $ROOT > $repo/btrfs-borg/subvolumes_of_$base
    fi
}

# function: see below
# parameter: ???
verify() {
    echo "do verification"
    echo success || fail from $? according to VERBOS setting
    # get verbos setting from `which btrfs-borg?`
    # get the list of archives to verify from somewhere
    # it would also be good to have a more verbose way to
    # verify the whole repo

    # That said, I'm thinking about using the epoch+seconds
    # thing to allow verification of all archives since 34198723649
    # eg: verify_since=`date -d "-3 month" +%s`
    # parse the date stamp, and if >= $verify_since then borg extract
    # --dry-run it

    # Alternatively, get the date stamp of the most recent archive, and verify
    # all archives taken from that (value minus 24h) range.

    # When borg supports it, switch to using --verify-data
}
