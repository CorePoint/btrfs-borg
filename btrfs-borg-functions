#
# This file contains functions used by btrfs-borg
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License v2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# Copyright (C) 2016-2017  Nicholas D Steeves <nsteeves@gmail.com>

# function: trim leading and trailing whitespace from strings
# parameter: string, taken from a field of a CSV
# TODO: test to see if this is truly necessary, and if not, drop it
trim() {
    local string="$*"
    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
    echo -n "$string"
}

# function: Other sanity checks
# parameter: To be written
# TODO: needs to iterate for new $backup_srcs
#       Other sanity checks.
#       CLEANUP -> move these to immediately before snapshot is taken
pre_snapshot() {
    if [ -d "$ROOT/$snaps" ]; then
        cd "$ROOT/$snaps"
        for i in $subs; do
            if [ -d "$i" ]; then
                AGE=$(stat -c %Y "$i")
                # this \/ isn't very nice...make snapshots as btrfs-borg-$i or $i.borg-snap instead
                echo "Moving existing snapshot of $i out of the way to
$i@$AGE"
                echo "TODO make snapshots as btrfs-borg_$i or $i.borg-snap instead"
                mv "$i" "$i"@"$AGE"
            fi
            sync
            btrfs sub sync "$ROOT"
            sync
        done
    else
        echo "$SNAPS not found! $COMMAND cannot continue."
        echo "create $SNAPS?"
        if [ -z ${NOTFOUND+x} ]; then
            echo -n "Proceed? "
            while true; do
                read choice
                case "$choice" in
                    yes | y | Yes | YES )
                        echo "Creating $SNAPS"
                        install -d -m 700
                        break
                        ;;
                    no | n | No | NO )
                        echo "Exiting safely."
                        exit 1
                        ;;
                    * )
                        printf "Please answer yes or no\n\n"
                        ;;
                esac
            done
        fi
        exit 1
    fi

    # PREP-STUFF.  TARGET FOR CLEANUP!
    # TODO: Make it a function
    # LOCAL VARS
    remuser="$(echo $repo | cut -d@ -f1)"
    remhost="$(echo $repo | cut -d@ -f2 | cut -d: -f1)"
    remrepo="$(echo $repo | cut -d: -f2)"

    # TODO: non-iterable sanity checks TARGET FOR CLEANUP!
    # Check for existence of intended borg REPO
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        ssh $remuser@$remhost "test -e $remrepo/config"
    elif [ ! -f "$repo/config" ]; then
        false
    fi
    if [ $? -ne 0 ]; then
        cat <<EOF
$repo/config not found!
Is your backup target disk plugged in and mounted?
Did you initialise the borg repository?
EOF
        exit 1
    fi
    echo "Configuration found for $repo"
}
# end pre_snapshot()

is_btrfs() {
    if [ "$(stat -f --format=%T $1)" == 'btrfs' ]; then
        echo "$1 is a btrfs volume"
    else
        echo "$1 is not a btrfs volume"
    fi
}

is_subvolume() {
    if [ "$(stat -f --format=%T $1)" == 'btrfs' ] && \
           [ "$(stat --format=%i $1)" -eq 256 ]; then
        echo "$1 is a btrfs subvolume"
    else
        echo "$1 is not a btrfs subvolume"
        false
    fi
}

# function: returns true if an LX container is found
# parameter: filesystem path
# TODO: write it
is_lxc() {
    echo "check for existence of $1/config?"
    echo "avoid using grep!"
    echo "grep $1/config for REGEX lxc.rootfs.backend.*btrfs"
}

# function:
# parameter: path that passes is_lxc's test
# TODO: make this function actually work
get_lxc_rootfs() {
    # from main(), use this function to test and get an LXC backup object
    #at this point $1=$ROOT from $f1 in main() eg: /btrfs-admin/SanDisk
    #at this point $2="/var/lib/lxc/my-container" from $f2 in main()
    is_btrfs $1/$2/rootfs
    ### Test for failure, echo MISCONFIGURED BTRFS-BORG and cleanup
    if [ $? -eq 0 ]; then
        #return the full path of subvol to snapshot
        echo -n "$1/$2/rootfs"
    else
        false
    fi
}

# TODO: RENAME AND REWORK THIS FUNCTION
# LOCAL VARS
lxc_start_stop() {
    if [ -n "$containers" ]; then
        unset lxcsnaps
        for i in $containers; do
            lxc-stop -n "$i"
            lxc-snapshot -n "$i"
            sync
            btrfs sub sync "$lxcdir"
            sync
            lxc-start -n "$i"
            if [ -z "$lxcsnaps" ]; then
                lxcsnaps="$(btrfs sub list $lxcdir | grep $i | tail -n1 | awk '{print $NF}')"
            else
                lxcsnaps="$lxcsnaps $(btrfs sub list $lxcdir | grep $i | tail -n1 | awk '{print $NF}')"
            fi
        done
        containers="$(echo $containers | tr ' ' '_')"
        lcontains="_"
        lcontains="$lcontains$containers"
    fi
}

# TODO: Each function needs a comment that documents what arguments
# it expects and what output it produces.
# LOCAL VARS
prepare () {
    echo "Preparing..."
    sync
    btrfs sub sync "$ROOT"
    sync
    for i in $subs; do
        btrfs sub snap -r "$ROOT/$i" "$ROOT/$snaps/$i"
        sync
        btrfs sub sync "$ROOT/$snaps/$i"
        sync
    done
    lsubs="$(echo $subs | tr ' ' '_')"
    if [ -n "$others" ]; then
        dirs=""
        for i in $others; do
            dirs="$dirs $(basename $i)"
        done
        dirs="$(echo $dirs | tr ' ' '_')"
        loths="_"
        loths="$loths$dirs"
    fi
}

# TODO: rename this function?  LOCAL VARS
do_backup() {
    echo "Doing backup (TODO: Needs to take vars from \$backup_unit"
    cd $ROOT/$snaps
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        stats=$HOME/time_stats_$DATE
    else
        stats=$repo/time_stats_$DATE
    fi
    borg create $verbos -p --stats $extraargs -C $comp \
         --exclude-caches \
         $repo::$lsubs$lcontains$loths-on-epoch+$DATE\.$comp \
         $subs $lxcsnaps $others
}

# Cleanup
# Must always clean up snapshots by default.
#
# TODO ASAP!!: remove LXC snapshot generated by $btrfs_borg
#   |-> refer lxc_start_stop()
# something like:
#
#for i in $containers; do
#      lxc-snapshot -L -n $i
#      EXPIRE="`lxc-snapshot -L -n $i | tail -1 | awk '{print $1}'`"
#      echo "Removing $EXPIRE"
#      lxc-snapshot -n get-transmissions -d $EXPIRE
#done
cleanup() {
    # TODO LOCAL VARS
    echo "Cleaning up Snapshots"
    (time (
            cd $ROOT/$snaps
            btrfs sub delete -c $subs
            echo "Syncing...please be patient, this could be slow"
            sync
            btrfs sub sync $ROOT
            sync)
     2>&3) 3>&2 2> $stats
    echo -n "Cleanup took "
    cat $stats
    echo
}

# Prune TODO: LOCAL VARS from backup_unit
# ESSENTIAL!
# BACKUP_UNITS='/btrfs-admin/Red, @stuff @more
# /btrfs-admin/Blue, @ @home /var/lib/lxc/my-container '
# Means my naming scheme needs to be:
# get basename of $ROOT
#     if basename is /btrfs-admin, then do nothing
#   else, BS=Blue
# $HOSTNAME-$BS-@stuff_@more is the creation and pruning prefix
# True-Blue-@_@home_my-container_$DATE
prune() {
    unset prune
    if [ -n "$hourly" ]; then prune="-H $hourly"; fi
    if [ -n "$daily" ]; then prune="$prune -d $daily"; fi
    if [ -n "$weekly" ]; then prune="$prune -w $weekly"; fi
    if [ -n "$monthly" ]; then prune="$prune -m $monthly"; fi
    if [ -n "$yearly" ]; then prune="$prune -y $yearly"; fi
    if [ -n "$prune" ]; then
        echo "Initiating pruning.  Please do not be alarmed if this takes forever"
        (time borg prune $verbos --stats $prune $repo 2>&3) \
            3>&2 2> $stats
        echo -n "Pruning took "
        cat $stats
        echo
        rm $stats
    fi
    # TODO: do something about \/ THIS \/
    base=`basename $ROOT`
}

# TODO Bundle stuff: Needs a better name?
# Needs to do something smart with respect to $backup_unit
bundle_stuff() {
    # Bundle stuff that will make restoring from backup easier
    if [ -n "$remuser" ] && [ -n "$remhost" ] && [ -n "$remrepo" ]; then
        ssh $remuser@$remhost "install -d -m 700  $remrepo/btrfs-borg"
        if [ -z ${archiveids+x} ]; then
            borg list $repo > $HOME/borg-list.$DATE
            chmod 400 $HOME/borg-list.$DATE
            # Add immutable ACL to $btrfs_borg-list.$DATE?
            scp $HOME/borg-list.$DATE \
                $remuser@$remhost:$remrepo/btrfs-borg/borg-list.$DATE && \
                rm $HOME/borg-list.$DATE
        fi
        ssh $remuser@$remhost "test -e $remrepo/btrfs-borg/$btrfs_borg"
        if [ $? -eq 0 ]; then
            ssh $remuser@$remhost "mv $remrepo/btrfs-borg/$btrfs_borg $remrepo/btrfs-borg/$btrfs_borg.old"
        fi
        install -m 500 "$0" $HOME/"$btrfs_borg.${DATE}" && \
            scp $HOME/$btrfs_borg.$DATE \
                $remuser@$remhost:$remrepo/btrfs-borg/$btrfs_borg && \
            rm $HOME/"$btrfs_borg.${DATE}"
        # \/ TODO \/
        #install -d -m 400 $BTRFS-BORG.CSV $repo/btrfs-borg/$BTRFS-BORG.CSV
        # TODO: make this iterate for multiple ROOTS
        btrfs sub list $ROOT | ssh $remuser@$remhost "cat > $remrepo/btrfs-borg/subvolumes_of_$base"
    else
        # Bundle stuff that will make restoring from backup easier
        mkdir -p $repo/btrfs-borg && chown 700 $repo/btrfs-borg
        if [ -f $repo/btrfs-borg/$btrfs_borg ]; then
            mv $repo/btrfs-borg/$btrfs_borg $repo/btrfs-borg/$btrfs_borg.old
        fi
        install -d -m 500 "$0" $repo/btrfs-borg/$btrfs_borg
        if [ -z ${archiveids+x} ]; then
            borg list $repo > $repo/btrfs-borg/borg-list.$DATE
            chmod 400 $repo/btrfs-borg/borg-list.$DATE
            # Add immutable ACL to $btrfs_borg-list.$DATE?
        fi
        # \/ TODO \/
        #install -d -m 400 $BTRFS-BORG.CSV $repo/btrfs-borg/$BTRFS-BORG.CSV
        # TODO: make this iterate for multiple ROOTS
        btrfs sub list $ROOT > $repo/btrfs-borg/subvolumes_of_$base
    fi
}

verify() {
    echo "do verification"
    echo success || fail from $? according to VERBOS setting
    # get verbos setting from `which btrfs-borg?`
    # get the list of archives to verify from somewhere
    # it would also be good to have a more verbose way to
    # verify the whole repo

    # That said, I'm thinking about using the epoch+seconds
    # thing to allow verification of all archives since 34198723649
    # eg: verify_since=`date -d "-3 month" +%s`
    # parse the date stamp, and if >= $verify_since then borg extract
    # --dry-run it

    # Alternatively, get the date stamp of the most recent archive, and verify
    # all archives taken from that (value minus 24h) range.

    # When borg supports it, switch to using --verify-data
}
